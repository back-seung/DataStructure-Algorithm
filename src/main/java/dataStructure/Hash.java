package dataStructure;public class Hash<K, V> implements HashI<K, V> {    class HashElement<K, V> implements Comparable<HashElement<K, V>> {        K key;        V value;        public HashElement(K key, V value) {            this.key = key;            this.value = value;        }        public int compareTo(HashElement<K, V> o) {            return ((Comparable<K>) this.key).compareTo(o.key);        }    }    int numElements;    int tableSize;    double maxLoadfactor;    LinkedList<HashElement<K, V>>[] harray;    // 해시 구현 생성자    public Hash(int tableSize) {        this.tableSize = tableSize;        // 형 변환        harray = (LinkedList<HashElement<K, V>>[]) new LinkedList[tableSize];        // 연결리스트 체이닝        for (int i = 0; i < tableSize; i++) {            harray[i] = new LinkedList<HashElement<K, V>>();        }        maxLoadfactor = 0.75;        numElements = 0;    }    public boolean add(K key, V value) {        // resize        if (loadFacotor() > maxLoadfactor) {            resize(tableSize * 2);        }        // 키와 값을 저장해 놓을 object he 정의        HashElement<K, V> he = new HashElement(key, value);        // he의 index 찾기        int hashval = key.hashCode();        hashval &= 0x7FFFFFFF;        hashval %= tableSize;        // add he        harray[hashval].addLast(he);        numElements++;        return true;    }    public boolean remove(K key, V value) {        // 키와 값을 저장해 놓을 object he 정의        HashElement<K, V> he = new HashElement(key, value);        // index 찾기        int hashval = key.hashCode();        hashval = hashval & 0x7FFFFFFF;        hashval = hashval % tableSize;        // 해당하는 index의 키와 값 제거        harray[hashval].remove(he);        numElements--;        return true;    }    public double loadFacotor() {        return this.numElements / this.tableSize;    }    public void resize(int newTableSize) {        LinkedList<HashElement<K, V>>[] new_array = (LinkedList<HashElement<K, V>>[]) new LinkedList[newTableSize];        for (int i = 0; i < newTableSize; i++) {            new_array[i] = new LinkedList<HashElement<K, V>>();        }        for(K key : this) {            V val = getValue(key);            HashElement<K, V> he = new HashElement<K, V>(key, val);            int hashVal = (key.hashCode() & 0x7FFFFFFF) % newTableSize;            new_array[hashVal].addLast(he);        }        // 덮어쓰기        harray = new_array;        tableSize = newTableSize;    }    public V getValue(K key) {        int hashVal = (key.hashCode() & 0x7FFFFFFF) % tableSize;        for (HashElement<K, V> he : harray[hashVal]) {            if (((Comparable<K>) key).compareTo(he.key) == 0) {                return he.value;            }        }        return null;    }}