package sort;public class BubbleSort {    /*     * 강의명 : 나동빈 실전 알고리즘 강좌 2강 - 버블 정렬(Bubble Sort)     * 문제 : 아래 주어진 배열을 1부터 10까지 순서대로 출력하는 문제.     * 아이디어 : 옆에 있는 값과 비교해서 더 작은 값을 앞에 보내면 어떨까?     * 손코딩 :     *   1. [1, 10, 5, 8, 7, 6, 4, 3, 2, 9] -- 1은 제자리에 있어도 됨     *   2. [1, *5*, *10*, 8, 7, 6, 4, 3, 2, 9]     *   3. [1, 5, *8*, *10* 7, 6, 4, 3, 2, 9]     *   4. [1, 5, 8, *7* *10*, 6, 4, 3, 2, 9]     *   5. [1, 5, 8, 7 *6*, *10*, 4, 3, 2, 9]     *   6. [1, 5, 8, 7, 6, *4*, *10*, 3, 2, 9]     *   7. [1, 5, 8, 7, 6, 4, *3*, *10*, 2, 9]     *   8. [1, 5, 8, 7, 6, 4, 3, *2*, *10*, 9]     *   9. [1, 5, 8, 7, 6, 4, 3, *2*, *9*, *10*] -- 1회차 반복 끝     *     * 시간 복잡도 :     * i = 0 일 때, 반복문 j에서는 배열을 순회하면서 양 옆 숫자를 서로 비교하고 더 작은 숫자를 앞으로 보내는 스와핑을 실시한다.     * i = 1 일 때, 반복문 j에서는 전과 같이 양 옆의 숫자를 서로 비교하는데, 이 때 제일 큰 숫자는 가장 끝의 위치에 있으므로 0 ~ 8까지의 위치만 조회한다.     * 그럼 반복은 (10 + 9 + 8 ... + 1)의 값, 총 55회를 순회하게 된다. 이를 bigO 표기법으로 표기하면 아래와 같다.     *     * 1. 등차수열 구하는 공식 : N * (N + 1) / 2     * 2. 상수항 제거 : N * N     * 3. bigO : O(N^2)이 된다.     *     * 따라서 빅오 표기법을 통해 시간 복잡도는 O(N^2)이라고 할 수 있다. 하지만 버블정렬은 선택정렬보다 비효율적이다.     * 그 이유는 선택정렬이 최소값과 최소값 원소의 위치를 찾고 배열의 위치를 한 번 변경하는 반면에, 버블정렬은 배열의 위치를 계속 변경하며 반복을 수행하기 때문이다.     * */    public static void main(String[] args) {        // 베열        final int[] nums = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};        // 임시값        int temp = 0;        for (int i = 0; i < nums.length; i++) {            for (int j = i; j < (nums.length - 1) - i; j++) {                if (nums[j] > nums[j + 1]) {                    temp = nums[j];                    nums[j] = nums[j + 1];                    nums[j + 1] = temp;                }            }        }        for (int i : nums) {            System.out.print(i + " ");        }    }}